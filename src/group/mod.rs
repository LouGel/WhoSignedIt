use std::collections::HashSet;
use std::fs::File;
use std::io::{BufReader, BufRead};
use std::path::Path;
use eyre::{Result, WrapErr};
use crate::error::AppError;
use crate::crypto::{PublicKey, public_key_from_hex, public_key_to_hex};
use tracing::{debug, info};

/// Group of public keys
#[derive(Clone)]
pub struct Group {
    keys: HashSet<String>,
}

impl Group {
    /// Create a new empty group
    pub fn new() -> Self {
        Self {
            keys: HashSet::new(),
        }
    }
    
    /// Load a group from a file (one public key per line, hex encoded)
    pub fn from_file<P: AsRef<Path>>(path: P) -> Result<Self> {
        let file = File::open(&path)
            .wrap_err_with(|| format!("Failed to open group file at {:?}", path.as_ref()))?;
        let reader = BufReader::new(file);
        
        let mut keys = HashSet::new();
        for (i, line) in reader.lines().enumerate() {
            let line = line?;
            let line = line.trim();
            if !line.is_empty() && !line.starts_with('#') {
                // Validate that it's a valid public key
                let key = public_key_from_hex(line)
                    .wrap_err_with(|| format!("Invalid public key on line {}: {}", i + 1, line))?;
                
                let key_hex = public_key_to_hex(&key);
                keys.insert(key_hex);
                debug!("Added key to group: {}", key);
            }
        }
        
        info!("Loaded {} keys from group file", keys.len());
        
        Ok(Self { keys })
    }
    
    /// Add a public key to the group
    pub fn add_key(&mut self, key: &PublicKey) {
        let key_hex = public_key_to_hex(key);
        self.keys.insert(key_hex);
        debug!("Added key to group: {}", key);
    }
    
    /// Check if a public key is in the group
    pub fn contains(&self, key: &PublicKey) -> bool {
        let key_hex = public_key_to_hex(key);
        let result = self.keys.contains(&key_hex);
        debug!("Key {} is in group: {}", key, result);
        result
    }
    
    /// Get all public keys in the group
    pub fn get_keys(&self) -> Result<Vec<PublicKey>> {
        let mut result = Vec::new();
        for key_hex in &self.keys {
            let key = public_key_from_hex(key_hex)?;
            result.push(key);
        }
        Ok(result)
    }
    
    /// Get the number of keys in the group
    pub fn len(&self) -> usize {
        self.keys.len()
    }
    
    /// Check if the group is empty
    pub fn is_empty(&self) -> bool {
        self.keys.is_empty()
    }
    
    /// Save the group to a file
    pub fn save_to_file<P: AsRef<Path>>(&self, path: P) -> Result<()> {
        use std::io::Write;
        
        let mut file = File::create(path)?;
        
        writeln!(file, "# Group public keys - Ethereum addresses")?;
        writeln!(file, "# DO NOT EDIT THIS FILE MANUALLY")?;
        writeln!(file)?;
        
        // Sort keys for consistent output
        let mut keys: Vec<_> = self.keys.iter().collect();
        keys.sort();
        
        for key in keys {
            writeln!(file, "{}", key)?;
        }
        
        Ok(())
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use crate::crypto::create_test_keypair;
    use tempfile::tempdir;
    
    #[test]
    fn test_group_basic_operations() {
        let (_, key1) = create_test_keypair();
        let (_, key2) = create_test_keypair();
        
        let mut group = Group::new();
        assert!(group.is_empty());
        
        group.add_key(&key1);
        assert_eq!(group.len(), 1);
        assert!(group.contains(&key1));
        assert!(!group.contains(&key2));
        
        group.add_key(&key2);
        assert_eq!(group.len(), 2);
        assert!(group.contains(&key2));
    }
    
    #[test]
    fn test_group_save_and_load() {
        let dir = tempdir().unwrap();
        let file_path = dir.path().join("test_group.txt");
        
        // Create a group with test keys
        let (_, key1) = create_test_keypair();
        let (_, key2) = create_test_keypair();
        
        let mut group = Group::new();
        group.add_key(&key1);
        group.add_key(&key2);
        
        // Save the group
        group.save_to_file(&file_path).unwrap();
        
        // Load the group
        let loaded_group = Group::from_file(&file_path).unwrap();
        
        // Check that loaded group has the same keys
        assert_eq!(loaded_group.len(), group.len());
        assert!(loaded_group.contains(&key1));
        assert!(loaded_group.contains(&key2));
    }
}
